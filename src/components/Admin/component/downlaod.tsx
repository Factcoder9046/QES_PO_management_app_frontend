import { jsPDF } from "jspdf";

export const handleDownload = (order:any) => {
  if (!order) {
    alert("No order data available for download.");
    return;
  }

  const doc = new jsPDF();

  // --- Page Dimensions ---
  // A4 size: 210 x 297 mm
  const pageWidth = doc.internal.pageSize.getWidth(); // 210
  // const pageHeight = doc.internal.pageSize.getHeight(); // 297
  const margin = 20; // 20mm margin on all sides

  // --- Set default font and styling ---
  doc.setFont("helvetica", "normal"); // Changed default back to normal to ensure only specified headings are bold
  doc.setFontSize(12);
  doc.setTextColor(0, 0, 0); // Black text by default

  // --- Header Section ---

  // Background for "Purchase Order" title (full width, from edge to edge)
  doc.setFillColor(10, 41, 117); // #0A2975 in RGB
  doc.rect(0, 0, pageWidth, 30, 'F'); // x, y, width, height, 'F' (fill)

  // Title "Purchase Order"
  doc.setFontSize(16);
  doc.setTextColor(255, 255, 255); // White text for title
  doc.text("Purchase Order", margin, 20);

  // "QESPL" text at top right corner
  doc.setFont("helvetica", "bold"); // Set font to bold
  doc.setFontSize(20); // Increased font size for QESPL
  // Calculate X to align 'QESPL' to the right margin
  const qesplTextWidth = doc.getTextWidth("QESPL");
  doc.text("QESPL", pageWidth - margin - qesplTextWidth, 20);
  doc.setFont("helvetica", "normal"); // Reset font style

  // Reset text color to black for the rest of the document
  doc.setTextColor(0, 0, 0);
  doc.setFontSize(12);

  // --- PO Details ---
  let currentY = 40; // Starting Y position after header

  doc.text(`PO Number: #${String(order.orderNumber || "___")}`, margin, currentY);
  currentY += 10;
  doc.text(
  `Order Date: ${
    order.createdAt ? String(order.createdAt).split('T')[0] : "___"
  }`,
  margin,
  currentY
);
  currentY += 10;
  doc.text(
    `Estimated Dispatch Date: ${String(
      order.estimatedDispatchDate ? order.estimatedDispatchDate.split('T')[0] : "___"
    )}`,
    margin,
    currentY
  );
  currentY += 10;

  // Status with dynamic colors only for the status value
  const status = String(order.status?.toUpperCase() || "COMPLETED");
  let statusValueColor = [0, 0, 0]; // Default black for status value

  switch (status) {
    case "PENDING":
      statusValueColor = [255, 193, 7]; // Yellow (RGB)
      break;
    case "DELAYED":
      statusValueColor = [255, 165, 0]; // Orange (RGB)
      break;
    case "COMPLETED":
      statusValueColor = [40, 167, 69]; // Green (RGB)
      break;
    case "REJECTED":
      statusValueColor = [220, 53, 69]; // Red (RGB)
      break;
    default:
      statusValueColor = [0, 0, 0]; // Black
      break;
  }
  doc.text(`Status: `, margin, currentY); // "Status: " part remains black
  doc.setTextColor(statusValueColor[0], statusValueColor[1], statusValueColor[2]); // Set color for the value
  // Position the status value right after "Status: "
  doc.text(status, margin + doc.getTextWidth("Status: "), currentY);
  doc.setTextColor(0, 0, 0); // Reset text color to black
  currentY += 20; // Add extra space before next section

  // --- Generated By & Order Through ---
  doc.setFont("helvetica", "bold"); // Set font to bold for "Generated By"
  doc.setFontSize(14);
  doc.text("Generated By", margin, currentY);
  doc.setFont("helvetica", "normal"); // Reset font style
  doc.setFontSize(12);
  currentY += 10;
  doc.text(`Employee Name: ${String(order.generatedBy?.username || "___")}`, margin, currentY);
  currentY += 10;
  doc.text(`Employee Id: ${String(order.generatedBy?.employeeId || "___")}`, margin, currentY);
  currentY += 10;
  doc.text(`Designation: ${String(order.generatedBy?.designation || "___")}`, margin, currentY);

  // Order Through (positioned relative to Generated By)
  const orderThroughX = pageWidth / 2 + 10; // Approximately center of the right half
  let orderThroughY = currentY - 30; // Align with "Generated By" if possible or adjust
  doc.setFont("helvetica", "bold"); // Set font to bold for "Order Through"
  doc.setFontSize(14);
  doc.text("Order Through", orderThroughX, orderThroughY);
  doc.setFont("helvetica", "normal"); // Reset font style
  doc.setFontSize(12);
  orderThroughY += 10;
  doc.text(`Employee Name: ${String(order.orderThrough?.username || "___")}`, orderThroughX, orderThroughY);
  orderThroughY += 10;
  doc.text(`Employee Id: ${String(order.orderThrough?.employeeId || "___")}`, orderThroughX, orderThroughY);
  orderThroughY += 10;
  doc.text(`Designation: ${String(order.orderThrough?.designation || "___")}`, orderThroughX, orderThroughY);

  // Ensure next section starts below both columns
  currentY = Math.max(currentY, orderThroughY) + 20;

  // --- Company Details Block ---
  // Removed the background fill for Company Details
  doc.setFont("helvetica", "bold"); // Set font to bold for "Company Details"
  doc.setFontSize(14);
  doc.text("Company Details", margin, currentY);
  doc.setFont("helvetica", "normal"); // Reset font style
  doc.setFontSize(12);
  currentY += 10;
  doc.text(`Client Name: ${String(order.clientName || "___")}`, margin, currentY);
  currentY += 10;
  doc.text(`Company Name: ${String(order.companyName || "___")}`, margin, currentY);
  currentY += 10;

  // Split address into lines for wrapping
  const addressText = String(order.address || "___");
  const splitAddress = doc.splitTextToSize(addressText, pageWidth - (2 * margin)); // Max width for address column
  doc.text(`Address: ${splitAddress.join(" ")}`, margin, currentY);
  currentY += (splitAddress.length * 5) + 5; // Adjust Y based on lines of address, plus a little extra space

  doc.text(`Zipcode: ${String(order.zipCode|| "___")}`, margin, currentY);
  currentY += 10;
  doc.text(`Contact No.: ${String(order.contact || "___")}`, margin, currentY);
  currentY += 10;
  doc.text(`GST No.: ${String(order.gstNumber|| "___")}`, margin, currentY);
  currentY += 20; // Extra space before next section

  // --- Product Information (Table) ---
  doc.setFont("helvetica", "bold"); // Set font to bold for "Product Information"
  doc.setFontSize(14);
  doc.text("Product Information", margin, currentY);
  doc.setFont("helvetica", "normal"); // Reset font style
  currentY += 10;

  // Table header background (light gray)
  const tableStartX = margin;
  const tableWidth = pageWidth - (2 * margin);
  const headerHeight = 8;
  const tableHeaderY = currentY - 2; // Positioned slightly above text
  doc.setFillColor(230, 230, 230); // Light gray
  doc.rect(tableStartX, tableHeaderY, tableWidth, headerHeight, 'F');

  doc.setFontSize(12);
  doc.setFont("helvetica", "bold"); // Bold for table headers
  doc.text("Product Name", tableStartX + 5, tableHeaderY + 5); // Align text within header background
  doc.text("Price", tableStartX + 70, tableHeaderY + 5);
  doc.text("Qty", tableStartX + 105, tableHeaderY + 5);
  doc.text("Remark", tableStartX + 135, tableHeaderY + 5);
  doc.setFont("helvetica", "normal"); // Reset font style
  currentY += headerHeight + 5; // Move Y below header

  // Table borders (Black)
  // doc.setDrawColor(0, 0, 0); // Black border
  // doc.setLineWidth(0.2); // Thin border

  // Initial horizontal border at the very top of the table header - REMOVED
  // doc.line(tableStartX, tableHeaderY, tableStartX + tableWidth, tableHeaderY);

  // Define original column X positions and calculate remark's available width
  const xProductName = tableStartX + 5;
  const xPrice = tableStartX + 70;
  const xQty = tableStartX + 105;
  const xRemark = tableStartX + 135;

  // Calculate the maximum width available for the Remark column text based on your existing layout
  // (tableStartX + tableWidth) is the right edge of the table.
  // We subtract xRemark to get the width from its starting point to the right edge.
  // Subtracting a small padding (e.g., 5mm) ensures text doesn't touch the right border.
  const remarkColumnContentWidth = (tableStartX + tableWidth) - xRemark - 5;

  const products = order.products || [
    { name: "Water Level Measurer - This is a very long product name that should wrap", price: "₹20,000/-", quantity: 2, remark: "This is a remark that is quite long and needs to wrap to multiple lines within its column to avoid overflowing and looking messy in the generated PDF document. It will keep expanding until it fits. Testing a very very very very very very very very long remark here." },
    { name: "Another Product", price: "₹5,000/-", quantity: 1, remark: "Short remark." },
    { name: "Third Item", price: "₹1,000/-", quantity: 5, remark: "Another long remark that goes on and on to test wrapping functionality. It needs to ensure it doesn't cross the column boundary and maintains readability. This is a continuation to make it even longer." },
  ];

  const lineHeight = 5; // Assuming 5mm per line for font size 12
  const verticalTextPadding = 2; // Small padding above and below text in cell

  products.forEach((product:any) => {
    // Horizontal line for each row (top border of current row content area) - REMOVED
    // doc.line(tableStartX, currentY, tableStartX + tableWidth, currentY);

    // Split the remark text based on the calculated available width
    const remarkLines = doc.splitTextToSize(String(product.remark || "No Remark"), remarkColumnContentWidth);

    // Calculate the height required for the remark text
    const remarkHeight = remarkLines.length * lineHeight;

    // Determine the row height based on the remark's height, ensuring a minimum for single-line content
    const calculatedRowHeight = Math.max(remarkHeight, lineHeight) + (2 * verticalTextPadding); // Add padding for top and bottom of content

    // Add text for each column
    doc.text(String(product.name || "NO PRODUCT"), xProductName, currentY + verticalTextPadding);
    doc.text(String(product.price || "___"), xPrice, currentY + verticalTextPadding);
    doc.text(String(product.quantity || 2), xQty, currentY + verticalTextPadding);
    // Draw the wrapped remark text
    doc.text(remarkLines, xRemark, currentY + verticalTextPadding);

    currentY += calculatedRowHeight; // Advance Y for the next row
  });

  // Final horizontal line at the bottom of the table - REMOVED
  // doc.line(tableStartX, currentY, tableStartX + tableWidth, currentY);

  // Draw vertical lines covering the entire table from header to last row - REMOVED
  // const finalTableBottomY = currentY; // The Y position of the bottom of the last row
  // doc.line(tableStartX, tableHeaderY, tableStartX, finalTableBottomY); // Left border
  // doc.line(tableStartX + 65, tableHeaderY, tableStartX + 65, finalTableBottomY); // Between Name and Price (original position)
  // doc.line(tableStartX + 100, tableHeaderY, tableStartX + 100, finalTableBottomY); // Between Price and Qty (original position)
  // doc.line(tableStartX + 125, tableHeaderY, tableStartX + 125, finalTableBottomY); // Between Qty and Remark (original position)
  // doc.line(tableStartX + tableWidth, tableHeaderY, tableStartX + tableWidth, finalTableBottomY); // Right border


  // Save the PDF
  doc.save(`PO_${String(order.poNumber || "new_PO")}.pdf`);
};